<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Pac-Style (Full, Tile-Step, Desktop)</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
  :root{--bg:#0f1115;--card:#151925;--text:#e6e6e6;--muted:#9aa3af;--accent:#65d6ff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:10px;padding:10px}
  canvas{background:var(--card);border:1px solid rgba(255,255,255,.08);border-radius:12px;image-rendering:pixelated}
  .hud{font:14px/1.2 monospace;align-self:flex-start}
  .hud b{color:var(--accent)}
  .hint{color:var(--muted);font:12px/1.2 monospace;text-align:center}
  .banner{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;color:#e6e6e6;font:16px/1.4 monospace;background:rgba(0,0,0,.55);padding:16px 18px;border-radius:10px;display:none;white-space:pre-line}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      Score: <b id="score">0</b> |
      Lives: <b id="lives">3</b> |
      Level: <b id="level">1</b> |
      Best: <b id="best">0</b>
    </div>
    <!-- 21x23 grid, 20px per cell -->
    <canvas id="game" width="420" height="460" aria-label="Pac-Style (Full Tile-Step)"></canvas>
    <div class="hint">Arrows/WASD to move • P pause • R/Enter reset • Esc back</div>
  </div>
  <div class="banner" id="banner"></div>

<script>
/* =================== CONSTANTS =================== */
const COLS=21, ROWS=23, CELL=20;
const DIRS={up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]};
const PAC_MS_BASE=100;      // Pac: one tile per 100ms
const GHOST_MS_BASE=110;    // Ghosts: one tile per 110ms
const EYES_MS=60;           // Eyes (eaten) go faster to the house
const TICK_MS=100;          // Global heartbeat for timers (phase, frightened, fruit)
const FRUIT_TTL_MS=12000;   // Fruit lifetime
const PHASES=[['scatter',7000],['chase',20000],['scatter',7000],['chase',20000],['scatter',5000],['chase',20000],['scatter',5000]];
const FRUIT_VALUES=[100,300,500,700,1000,1500];

/* =================== CANVAS & HUD =================== */
const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
const scoreEl=document.getElementById('score'), livesEl=document.getElementById('lives'),
      levelEl=document.getElementById('level'), bestEl=document.getElementById('best'),
      banner=document.getElementById('banner');
let best=+localStorage.getItem('pac_full_tile_best')||0; bestEl.textContent=best;

/* =================== MAP (strict width) =================== */
const RAW_MAP=[
  "#####################",
  "#.........#.........#",
  "#.###.###.#.###.###.#",
  "#o###.###.#.###.###o#",
  "#...................#",
  "#.###.#.#####.#.###.#",
  "#.....#...#...#.....#",
  "#####.### # ###.#####",
  "     .#       #.     ",
  "#####.# ##D## #.#####",
  "#..... . #   # . .....",
  "#####.# ##### #.#####",
  "     .#       #.     ",
  "#####.# ##### #.#####",
  "#.........#.........#",
  "#.###.###.#.###.###.#",
  "#o..#...........#..o#",
  "###.#.#.#####.#.#.###",
  "#.....#...#...#.....#",
  "#.#######.#.#######.#",
  "#.........#.........#",
  "#####################",
  "#####################"
];
// normalize rows to exactly COLS
function normRow(s){
  s=(s||"").replace(/[^\#\.oD ]/g,' ');
  if (s.length<COLS) s+=' '.repeat(COLS-s.length);
  if (s.length>COLS) s=s.slice(0,COLS);
  return s;
}
const baseGrid = RAW_MAP.slice(0,ROWS).map(normRow).map(r=>r.split(''));
while(baseGrid.length<ROWS) baseGrid.push(normRow('').split(''));
let grid = baseGrid.map(r=>r.slice()); // working copy

/* =================== HELPERS =================== */
function inBounds(x,y){ return x>=0&&x<COLS&&y>=0&&y<ROWS; }
function tile(x,y){ if(!inBounds(x,y)) return '#'; const v=grid[y][x]; return (v===undefined?'#':v); }
function setTile(x,y,v){ if(inBounds(x,y)) grid[y][x]=v; }
function wrapX(x){ return (x+COLS)%COLS; }
function wrapY(y){ return (y+ROWS)%ROWS; }
function wrapDelta(a,b,mod){ const r=(a-b+mod)%mod; return r>mod/2? r-mod : r; }
function manhattanWrap(ax,ay,bx,by){ return Math.abs(wrapDelta(ax,bx,COLS))+Math.abs(wrapDelta(ay,by,ROWS)); }

/* =================== ENTITIES (TILE COORDS) =================== */
const pac={ tx:10, ty:16, dir:DIRS.left.slice(), next:DIRS.left.slice() };

function ghostFactory(name,color,seed,releaseMs){
  return { name, color, tx:seed[0], ty:seed[1], dir:DIRS.left.slice(),
           state:'pen', frightMs:0, releaseMs, stepMs:GHOST_MS_BASE };
}
const seeds={ red:[10,10], pink:[9,12], cyan:[11,12], orange:[10,12] };
let ghosts=[
  ghostFactory('red',    '#ef4444', seeds.red,    0),
  ghostFactory('pink',   '#f472b6', seeds.pink,   2000),
  ghostFactory('cyan',   '#22d3ee', seeds.cyan,   5000),
  ghostFactory('orange', '#f59e0b', seeds.orange, 8000),
];

let score=0, lives=3, level=1, running=true, gameOver=false;
let frightMs=0, chain=0;
let phaseIdx=0, phaseMs=PHASES[0][1];
let dotsTotal=0, dotsEaten=0;
let fruit={ active:false, tx:0, ty:0, dir:[1,0], ttl:0, value:100 };
let fruitSpawns={ q1:false, q2:false };

/* =================== PASSABILITY =================== */
function passForPac(nx,ny){ const t=tile(wrapX(nx),wrapY(ny)); return t!=='#' && t!=='D'; }
function passForGhost(nx,ny){
  const t=tile(wrapX(nx),wrapY(ny));
  return t!=='#'; // ghosts can pass the door 'D'
}

/* =================== INPUT (keyboard only) =================== */
const KEYMAP={ArrowUp:'up',ArrowDown:'down',ArrowLeft:'left',ArrowRight:'right',w:'up',s:'down',a:'left',d:'right'};
addEventListener('keydown',e=>{
  const k=e.key;
  if(k==='Escape'){ location.href='index.html'; return; }
  if(k==='p'||k==='P'){ togglePause(); return; }
  if(k==='r'||k==='R'||k==='Enter'){ reset(true); return; }
  const name=KEYMAP[k.length===1?k.toLowerCase():k]; if(!name) return;
  pac.next=DIRS[name].slice();
});

/* =================== TIMERS =================== */
let pacTimer=null, globalTimer=null;
const ghostTimers=new Map();
function startTimers(){
  stopTimers();
  pacTimer=setInterval(()=>{ if(running && !gameOver) stepPac(); draw(); }, pacStepMs());
  for(const g of ghosts) ghostTimers.set(g.name, setInterval(()=>{ if(running && !gameOver) stepGhost(g); }, g.stepMs));
  globalTimer=setInterval(()=>{ if(running && !gameOver) tickGlobal(TICK_MS); }, TICK_MS);
}
function stopTimers(){
  if(pacTimer) clearInterval(pacTimer); pacTimer=null;
  if(globalTimer) clearInterval(globalTimer); globalTimer=null;
  for(const id of ghostTimers.values()) clearInterval(id);
  ghostTimers.clear();
}
function restartGhostTimer(g){
  const id=ghostTimers.get(g.name); if(id) clearInterval(id);
  ghostTimers.set(g.name, setInterval(()=>{ if(running && !gameOver) stepGhost(g); }, g.stepMs));
}
function pacStepMs(){
  // speed ramps a bit per level
  return Math.max(65, PAC_MS_BASE - (level-1)*3);
}

/* =================== GLOBAL TICK (phases, frightened, fruit, releases) =================== */
let elapsedMs=0;
function tickGlobal(dt){
  elapsedMs += dt;

  // scatter/chase phase timing (ignore while frightened)
  if (frightMs<=0){
    phaseMs -= dt;
    if (phaseMs<=0){
      phaseIdx = Math.min(phaseIdx+1, PHASES.length-1);
      phaseMs = PHASES[phaseIdx][1];
    }
  }

  // frightened timer
  if (frightMs>0){
    frightMs -= dt;
    if (frightMs<=0){
      ghosts.forEach(g=>{ if(g.state==='fright') g.state='normal'; g.stepMs=ghostStepMs(g); restartGhostTimer(g); });
      chain=0;
    }
  }

  // fruit timer
  if (fruit.active){
    fruit.ttl -= dt;
    if (fruit.ttl<=0) fruit.active=false;
    else moveFruit();
  }

  // ghost releases
  for (const g of ghosts){
    if (g.state==='pen' && elapsedMs>=g.releaseMs){
      // open the door: pick direction upward if possible, else left
      const exit=[0,-1]; if (passForGhost(g.tx, g.ty-1)) g.dir=exit.slice();
      g.state='normal'; g.stepMs=ghostStepMs(g); restartGhostTimer(g);
    }
  }
}

/* =================== MOVEMENT / STEPS =================== */
function tryTurnAndStep(entity, passFn){
  // try queued turn
  const nd=entity.next||entity.dir, d=entity.dir;
  const nx=wrapX(entity.tx+nd[0]), ny=wrapY(entity.ty+nd[1]);
  if (passFn(nx,ny)) entity.dir=nd.slice();
  // forward
  const fx=wrapX(entity.tx+entity.dir[0]), fy=wrapY(entity.ty+entity.dir[1]);
  if (passFn(fx,fy)){ entity.tx=fx; entity.ty=fy; return true; }
  return false;
}

function stepPac(){
  tryTurnAndStep(pac, passForPac);

  // pellets / power
  const t=tile(pac.tx,pac.ty);
  if (t==='.'){ setTile(pac.tx,pac.ty,' '); score+=10; dotsEaten++; maybeSpawnFruit(); }
  else if (t==='o'){
    setTile(pac.tx,pac.ty,' '); score+=50; dotsEaten++; maybeSpawnFruit();
    // frightened start
    frightMs = Math.max(2000, 6000 - (level-1)*500); // 6s decaying, min 2s
    chain=0;
    ghosts.forEach(g=>{
      if (g.state==='normal'){ g.state='fright'; g.stepMs = ghostStepMs(g); restartGhostTimer(g); }
      g.frightFlash=false;
    });
  }

  // eat fruit
  if (fruit.active && pac.tx===fruit.tx && pac.ty===fruit.ty){
    score += fruit.value; fruit.active=false;
  }

  // collisions
  for (const g of ghosts){
    if (pac.tx===g.tx && pac.ty===g.ty){
      if (g.state==='fright'){
        // eat ghost
        g.state='eyes'; g.stepMs=EYES_MS; restartGhostTimer(g);
        chain=Math.min(chain+1,4);
        score += 200 * (1<<(chain-1)); // 200,400,800,1600
      } else if (g.state!=='eyes'){
        return death();
      }
    }
  }

  // level complete?
  if (remainingDots()===0){
    level++;
    showBanner(`Level ${level}\nNew speed & timers`); setTimeout(hideBanner,900);
    nextLevel();
  }

  updateHUD();
}

function stepGhost(g){
  // EYES: return to house center (10,11). When arrived, go pen->normal soon.
  if (g.state==='eyes'){
    const tgt={tx:10,ty:11};
    ghostChaseStep(g, tgt, true);
    if (g.tx===tgt.tx && g.ty===tgt.ty){
      g.state='pen'; g.releaseMs = elapsedMs + 1000; g.stepMs=GHOST_MS_BASE; restartGhostTimer(g);
    }
    return;
  }

  // PRISON (pen): oscillate left-right until global release tick handles it
  if (g.state==='pen'){
    // small jiggle inside pen area
    const opts=[[1,0],[-1,0],[0,1],[0,-1]].filter(d=>passForGhost(g.tx+d[0],g.ty+d[1]));
    if (opts.length){
      const d=opts[(Math.random()*opts.length)|0]; g.dir=d.slice();
      g.tx=wrapX(g.tx+g.dir[0]); g.ty=wrapY(g.ty+g.dir[1]);
    }
    return;
  }

  // NORMAL or FRIGHT: choose direction at intersections
  const mode = (frightMs>0 && g.state==='fright') ? 'fright' : PHASES[phaseIdx][0]; // scatter/chase
  const tgt = (mode==='scatter') ? scatterCorner(g) : chaseTarget(g);
  const randomFactor = (mode==='fright') ? 0.7 : 0.2; // more random when frightened
  const avoidReverse = true;
  ghostMoveToward(g, tgt, randomFactor, avoidReverse);
}

function ghostMoveToward(g, tgt, rand, avoidReverse){
  const choices=[];
  for (const d of [DIRS.up,DIRS.down,DIRS.left,DIRS.right]){
    if (avoidReverse && (d[0]===-g.dir[0] && d[1]===-g.dir[1])) continue;
    if (passForGhost(g.tx+d[0], g.ty+d[1])) choices.push(d);
  }
  if (choices.length===0){ g.dir=[-g.dir[0],-g.dir[1]]; return; }

  let pick=null;
  if (Math.random()<rand){
    pick = choices[(Math.random()*choices.length)|0];
  } else {
    let best=Infinity, dir=choices[0];
    for (const d of choices){
      const nx=wrapX(g.tx+d[0]), ny=wrapY(g.ty+d[1]);
      const dist = manhattanWrap(nx,ny,tgt.tx,tgt.ty);
      if (dist<best){ best=dist; dir=d; }
    }
    pick = dir;
  }
  g.dir=pick.slice();
  g.tx=wrapX(g.tx+g.dir[0]); g.ty=wrapY(g.ty+g.dir[1]);
}

function ghostChaseStep(g, tgt, avoidReverse){
  ghostMoveToward(g, tgt, 0, avoidReverse);
}

function ghostStepMs(g){
  if (g.state==='fright') return Math.max(90, GHOST_MS_BASE + 20); // slower when frightened
  if (g.state==='eyes') return EYES_MS;
  return Math.max(80, GHOST_MS_BASE - (level-1)*3);
}

function chaseTarget(g){
  const px=pac.tx, py=pac.ty;
  if (g.name==='red')   return {tx:px, ty:py};
  if (g.name==='pink')  return {tx:wrapX(px+pac.dir[0]*4), ty:wrapY(py+pac.dir[1]*4)};
  if (g.name==='cyan')  return {tx:wrapX(px-pac.dir[0]*2), ty:wrapY(py-pac.dir[1]*2)};
  if (g.name==='orange'){
    const far = manhattanWrap(g.tx,g.ty,px,py) > 6;
    return far ? {tx:px,ty:py} : {tx:1,ty:ROWS-2};
  }
  return {tx:px,ty:py};
}
function scatterCorner(g){
  const corners={ red:[COLS-2,1], pink:[1,1], cyan:[COLS-2,ROWS-2], orange:[1,ROWS-2] };
  const c=corners[g.name]||[COLS-2,1];
  return {tx:c[0], ty:c[1]};
}

/* =================== FRUIT =================== */
function maybeSpawnFruit(){
  const q1 = Math.floor(dotsTotal*0.25);
  const q2 = Math.floor(dotsTotal*0.60);
  if (!fruitSpawns.q1 && dotsEaten>=q1){ spawnFruit(); fruitSpawns.q1=true; }
  if (!fruitSpawns.q2 && dotsEaten>=q2){ spawnFruit(); fruitSpawns.q2=true; }
}
function spawnFruit(){
  const val = FRUIT_VALUES[Math.min(level-1, FRUIT_VALUES.length-1)];
  // appear near center corridor
  const spots=[[1,(ROWS/2|0)], [COLS-2,(ROWS/2|0)], [10,8]];
  const s = spots[(Math.random()*spots.length)|0];
  fruit={ active:true, tx:s[0], ty:s[1], dir:[(Math.random()<0.5?1:-1),0], ttl:FRUIT_TTL_MS, value:val };
}
function moveFruit(){
  // fruit wanders corridor; random turns at intersections, avoids walls
  const opts=[];
  for (const d of [DIRS.up,DIRS.down,DIRS.left,DIRS.right]){
    if (d[0]===-fruit.dir[0] && d[1]===-fruit.dir[1]) continue;
    if (passForPac(fruit.tx+d[0], fruit.ty+d[1])) opts.push(d);
  }
  if (opts.length && Math.random()<0.3) fruit.dir = opts[(Math.random()*opts.length)|0].slice();
  const fx=wrapX(fruit.tx+fruit.dir[0]), fy=wrapY(fruit.ty+fruit.dir[1]);
  if (passForPac(fx,fy)){ fruit.tx=fx; fruit.ty=fy; }
}

/* =================== GAME FLOW =================== */
function remainingDots(){
  let c=0; for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const t=tile(x,y); if(t==='.'||t==='o') c++; }
  return c;
}
function countDots(){ let c=0; for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const t=tile(x,y); if(t==='.'||t==='o') c++; } return c; }

function nextLevel(){
  // rebuild grid from base, keep same maze
  grid = baseGrid.map(r=>r.slice());
  // reset state
  dotsTotal=countDots(); dotsEaten=0; fruitSpawns={q1:false,q2:false}; fruit.active=false;
  frightMs=0; chain=0; phaseIdx=0; phaseMs=PHASES[0][1]; elapsedMs=0;
  // positions
  Object.assign(pac, {tx:10,ty:16,dir:DIRS.left.slice(),next:DIRS.left.slice()});
  ghosts=[
    ghostFactory('red',    '#ef4444', seeds.red,    0),
    ghostFactory('pink',   '#f472b6', seeds.pink,   2000),
    ghostFactory('cyan',   '#22d3ee', seeds.cyan,   5000),
    ghostFactory('orange', '#f59e0b', seeds.orange, 8000),
  ];
  stopTimers(); startTimers();
}

function death(){
  lives--;
  if (lives<=0){
    running=false; gameOver=true;
    if (score>best){ best=score; localStorage.setItem('pac_full_tile_best', String(best)); }
    bestEl.textContent=best;
    showBanner(`Game Over\nScore ${score} • Level ${level}\nPress R/Enter to play again`);
    stopTimers();
    return;
  }
  // reset positions, keep board & level
  Object.assign(pac, {tx:10,ty:16,dir:DIRS.left.slice(),next:DIRS.left.slice()});
  ghosts=[
    ghostFactory('red',    '#ef4444', seeds.red,    0),
    ghostFactory('pink',   '#f472b6', seeds.pink,   2000),
    ghostFactory('cyan',   '#22d3ee', seeds.cyan,   5000),
    ghostFactory('orange', '#f59e0b', seeds.orange, 8000),
  ];
  frightMs=0; chain=0; phaseIdx=0; phaseMs=PHASES[0][1]; elapsedMs=0;
  stopTimers(); startTimers();
}

function reset(full=false){
  if (full){
    grid = baseGrid.map(r=>r.slice());
    score=0; lives=3; level=1;
  }
  gameOver=false; running=true;
  dotsTotal=countDots(); dotsEaten=0; fruitSpawns={q1:false,q2:false}; fruit.active=false;
  frightMs=0; chain=0; phaseIdx=0; phaseMs=PHASES[0][1]; elapsedMs=0;
  Object.assign(pac, {tx:10,ty:16,dir:DIRS.left.slice(),next:DIRS.left.slice()});
  ghosts=[
    ghostFactory('red',    '#ef4444', seeds.red,    0),
    ghostFactory('pink',   '#f472b6', seeds.pink,   2000),
    ghostFactory('cyan',   '#22d3ee', seeds.cyan,   5000),
    ghostFactory('orange', '#f59e0b', seeds.orange, 8000),
  ];
  stopTimers(); startTimers(); hideBanner(); updateHUD(); draw();
}

function updateHUD(){ scoreEl.textContent=score; livesEl.textContent=lives; levelEl.textContent=level; }
function togglePause(){ if(gameOver) return; running=!running; running?hideBanner():showBanner('Paused\nPress P to resume'); }
function showBanner(msg){ banner.textContent=msg; banner.style.display='block'; }
function hideBanner(){ banner.style.display='none'; }

/* =================== RENDER =================== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#0d1018'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // tiles
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const t=tile(x,y), px=x*CELL, py=y*CELL;
      if(t==='#' || t==='D'){
        ctx.fillStyle = (t==='D') ? '#334155' : '#1e3a8a';
        ctx.fillRect(px+1,py+1,CELL-2,CELL-2);
      } else if (t==='.'){
        ctx.fillStyle='#e6e6e6'; ctx.beginPath(); ctx.arc(px+CELL/2,py+CELL/2,2,0,Math.PI*2); ctx.fill();
      } else if (t==='o'){
        // flash power pellet when frightened nearly over
        const flash = (frightMs>0 && frightMs<2000) ? (Math.floor(performance.now()/120)%2===0) : true;
        if (flash){ ctx.fillStyle='#fbbf24'; ctx.beginPath(); ctx.arc(px+CELL/2,py+CELL/2,5,0,Math.PI*2); ctx.fill(); }
      }
    }
  }

  // fruit
  if (fruit.active){
    const fx=fruit.tx*CELL+CELL/2, fy=fruit.ty*CELL+CELL/2;
    ctx.fillStyle='#ff3b7b';
    ctx.beginPath(); ctx.arc(fx,fy,CELL*0.35,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#0f1115'; ctx.fillRect(fx-2,fy-4,4,6);
  }

  // Pac
  const pxc=pac.tx*CELL+CELL/2, pyc=pac.ty*CELL+CELL/2;
  const base=Math.atan2(pac.dir[1],pac.dir[0]); const mouth=(Math.sin(performance.now()/80)+1)/4 + 0.15;
  ctx.fillStyle='#facc15';
  ctx.beginPath(); ctx.moveTo(pxc,pyc); ctx.arc(pxc,pyc,CELL*0.45, base+mouth, base-mouth, false); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#0f1115';
  const ex = pac.dir[1]===0 ? (pac.dir[0]===1?4:-4) : 0, ey = pac.dir[0]===0 ? -6 : -4;
  ctx.beginPath(); ctx.arc(pxc+ex, pyc+ey, 2, 0, Math.PI*2); ctx.fill();

  // Ghosts
  for (const g of ghosts){
    const gx=g.tx*CELL+CELL/2, gy=g.ty*CELL+CELL/2, r=CELL*0.45;
    let color=g.color;
    if (g.state==='fright'){
      // frightened blue with flash near end
      const flashing = (frightMs<2000) ? (Math.floor(performance.now()/120)%2===0) : false;
      color = flashing ? '#93c5fd' : '#60a5fa';
    } else if (g.state==='eyes'){
      color = '#94a3b8';
    }
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.arc(gx,gy,r,Math.PI,0,false); ctx.lineTo(gx+r,gy+r*0.9);
    for(let i=2;i>=-2;i--){ const tx=gx+(i/2)*r; ctx.lineTo(tx + r/4, gy + r*0.9); }
    ctx.closePath(); ctx.fill();
    // eyes
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(gx-6,gy-2,4,0,Math.PI*2); ctx.arc(gx+6,gy-2,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#0f1115'; ctx.beginPath(); ctx.arc(gx-6+g.dir[0]*2, gy-2+g.dir[1]*2, 2,0,Math.PI*2); ctx.arc(gx+6+g.dir[0]*2, gy-2+g.dir[1]*2, 2,0,Math.PI*2); ctx.fill();
  }
}

/* =================== INIT =================== */
function init(){
  // Count dots for fruit thresholds
  dotsTotal=countDots(); dotsEaten=0; fruitSpawns={q1:false,q2:false}; fruit.active=false;
  startTimers(); draw();
}
function remainingDots(){ let c=0; for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const t=tile(x,y); if(t==='.'||t==='o') c++; } return c; }

reset(true); init();
</script>
</body>
</html>
