<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pong</title>
  <style>
    html,body{height:100%;margin:0;background:#0f1115;color:#e6e6e6;display:grid;place-items:center;font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif}
    canvas{background:#151925;border:1px solid rgba(255,255,255,.08);border-radius:12px;image-rendering:pixelated;touch-action:none}
    .hud{position:fixed;top:12px;left:50%;transform:translateX(-50%);font-weight:600;letter-spacing:.5px}
    .hint{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);color:#9aa3af;font-size:14px}
  </style>
</head>
<body>
  <canvas id="game" width="720" height="480" aria-label="Pong game canvas" role="img"></canvas>
  <div class="hud" id="hud">0 : 0</div>
  <div class="hint" id="hint">W/S or ↑/↓ to move • P: pause • R: reset • Click/drag or swipe on mobile</div>
  <script>
    // --- Setup
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');

    // Resize for device while keeping aspect ratio
    function fit(){
      const maxW = Math.min(innerWidth-24, 960);
      const maxH = Math.min(innerHeight-24, 640);
      const target = 720/480; // base aspect
      let w = maxW, h = Math.round(maxW/target);
      if(h>maxH){ h=maxH; w=Math.round(maxH*target); }
      canvas.style.width = w+"px"; canvas.style.height = h+"px";
    }
    addEventListener('resize', fit); fit();

    // Input (keyboard)
    const keys = new Set();
    addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); if(['arrowup','arrowdown','w','s',' '].includes(e.key.toLowerCase())) e.preventDefault(); });
    addEventListener('keyup',   e => keys.delete(e.key.toLowerCase()));

    // Input (mouse / touch drag for left paddle)
    let pointerY = null, dragging=false;
    canvas.addEventListener('pointerdown', e=>{ dragging=true; pointerY = e.clientY; canvas.setPointerCapture(e.pointerId); });
    canvas.addEventListener('pointerup',   e=>{ dragging=false; pointerY=null; canvas.releasePointerCapture(e.pointerId); });
    canvas.addEventListener('pointermove', e=>{ if(dragging){ pointerY = e.clientY; }});

    // Simple beep sounds via Web Audio
    const audio = new (window.AudioContext||window.webkitAudioContext)();
    function beep(freq=600, dur=0.05){
      try{
        const o = audio.createOscillator(); const g = audio.createGain();
        o.connect(g); g.connect(audio.destination);
        o.type='square'; o.frequency.value=freq; g.gain.value=0.04; // quiet
        const t = audio.currentTime; o.start(t); o.stop(t+dur);
      }catch(_){/* ignore autoplay blocks */}
    }

    // Game state
    const W=720,H=480, PAD_H=80, PAD_W=10, BALL=10;
    const state = {
      p1:{x:20,y:H/2-PAD_H/2, vy:0, score:0},
      p2:{x:W-20-PAD_W,y:H/2-PAD_H/2, vy:0, score:0},
      ball:{x:W/2, y:H/2, vx:200*(Math.random()<.5?1:-1), vy:120*(Math.random()<.5?1:-1)},
      paused:false, winner:null
    };

    // Helpers
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function resetBall(dir){
      state.ball.x=W/2; state.ball.y=H/2;
      const speed = 240 + Math.random()*60;
      const angle = (Math.random()*0.6 - 0.3); // slight angle
      state.ball.vx = speed * (dir || (Math.random()<.5?1:-1));
      state.ball.vy = (speed*0.6) * Math.sin(angle);
    }
    function resetGame(){ state.p1.score=state.p2.score=0; state.winner=null; resetBall(); }

    // Main loop
    let last=0; requestAnimationFrame(loop);
    function loop(t){
      const dt = Math.min(0.033,(t-last)/1000); last=t;
      if(!state.paused && !state.winner) update(dt);
      draw(); requestAnimationFrame(loop);
    }

    function update(dt){
      // Player input (P1)
      const speed = 360;
      state.p1.vy = 0;
      if(keys.has('w') || keys.has('arrowup'))   state.p1.vy = -speed;
      if(keys.has('s') || keys.has('arrowdown')) state.p1.vy =  speed;
      if(pointerY!==null){
        // map pointer to canvas space
        const rect = canvas.getBoundingClientRect();
        const cy = (pointerY - rect.top) * (H/rect.height);
        const targetY = cy - PAD_H/2; // center paddle on finger
        const diff = targetY - state.p1.y; state.p1.vy = clamp(diff*10, -speed, speed);
      }
      state.p1.y = clamp(state.p1.y + state.p1.vy*dt, 0, H-PAD_H);

      // Simple AI (P2): ease toward ball y with reaction lag
      const aiSpeed = 300; const target = state.ball.y - PAD_H/2;
      const diff = target - state.p2.y; state.p2.vy = clamp(diff*6, -aiSpeed, aiSpeed);
      state.p2.y = clamp(state.p2.y + state.p2.vy*dt, 0, H-PAD_H);

      // Move ball
      const b = state.ball; b.x += b.vx*dt; b.y += b.vy*dt;

      // Collide with top/bottom
      if(b.y <= 0){ b.y=0; b.vy = Math.abs(b.vy); beep(300); }
      if(b.y+BALL >= H){ b.y=H-BALL; b.vy = -Math.abs(b.vy); beep(300); }

      // Paddle collision helper
      function collide(px,py,pw,ph){
        if(b.x < px+pw && b.x+BALL > px && b.y < py+ph && b.y+BALL > py){
          // reflect and add some english based on hit position
          const hit = (b.y + BALL/2) - (py + ph/2);
          const norm = hit / (ph/2);
          b.vx = -b.vx * 1.05; // speed up slightly
          b.vy = (Math.abs(b.vx)*0.25) * norm;
          // nudge outside to avoid sticking
          if(px < W/2) b.x = px+pw; else b.x = px-BALL;
          beep(600);
        }
      }
      collide(state.p1.x,state.p1.y,PAD_W,PAD_H);
      collide(state.p2.x,state.p2.y,PAD_W,PAD_H);

      // Scoring
      if(b.x+BALL < 0){ state.p2.score++; beep(200); resetBall(+1); }
      if(b.x > W){ state.p1.score++; beep(200); resetBall(-1); }
      hud.textContent = `${state.p1.score} : ${state.p2.score}`;

      // Win condition
      if(state.p1.score>=11 || state.p2.score>=11){
        state.winner = state.p1.score>state.p2.score ? 'You win!' : 'CPU wins!';
        state.paused = true;
      }
    }

    function draw(){
      // Court
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='#0d1018'; ctx.fillRect(0,0,W,H);
      // center dashed line
      ctx.fillStyle='#2a3142';
      for(let y=0;y<H;y+=22){ ctx.fillRect(W/2-2, y, 4, 12); }
      // paddles & ball
      ctx.fillStyle='#e6e6e6';
      ctx.fillRect(state.p1.x, state.p1.y, PAD_W, PAD_H);
      ctx.fillRect(state.p2.x, state.p2.y, PAD_W, PAD_H);
      ctx.fillRect(state.ball.x, state.ball.y, BALL, BALL);

      if(state.paused){
        ctx.fillStyle='#9aa3af'; ctx.font='24px monospace'; ctx.textAlign='center';
        if(state.winner){ ctx.fillText(state.winner, W/2, H/2-20); }
        ctx.fillText('Press P to resume • R to reset • Esc to go back', W/2, H/2+12);
        ctx.textAlign='start';
      }
    }

    // Controls: pause/reset/escape
    addEventListener('keydown', e=>{
      const k = e.key.toLowerCase();
      if(k==='p'){ state.paused=!state.paused; }
      if(k==='r'){ resetGame(); state.paused=false; state.winner=null; }
      if(k==='escape'){ location.href='index.html'; }
    });
  </script>
</body>
</html>